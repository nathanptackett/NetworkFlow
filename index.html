   <!DOCTYPE html>
   <html>
      <head>
         <title>Main</title>
         <script  src="https://threejs.org/build/three.js"></script>
         <script  src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
         <script  src="./LinkedList.js"></script>

         <script id="vertexShader" type="x-shader/x-vertex">
            precision highp float;

            attribute vec3 position;

            varying vec3 vPosition;

            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;

            void main()   {
               vPosition = position;

               gl_Position = projectionMatrix*modelViewMatrix*vec4(position, 1.0 );
            }
         </script>

         <script id="edgeShader" type="x-shader/x-fragment">
            precision highp float;

            varying vec3 vPosition;
            varying vec3 vNormal;

            uniform float ringWidth;
            uniform vec3 ringColor;
            uniform float spaceBetweenRings;
            uniform vec3 pipeColor;
            uniform float percentFilled;

            void main()   {
               float newPosition = vPosition.y - (spaceBetweenRings + ringWidth)*percentFilled;
               float posY;
               bool positiveY;
               if(newPosition < 0.0)
               {
                  posY = newPosition * -1.0;
                  positiveY = false;
               }
               else
               {
                  posY = newPosition;
                  positiveY = true;
               }

               float moddedVal = mod(posY, ringWidth + spaceBetweenRings);
               if (moddedVal < ringWidth)
               {
                  if(positiveY)
                  {
                     float distanceToCenter = (ringWidth / 2.0) - moddedVal;
                     if(distanceToCenter < 0.0)
                        distanceToCenter *= -1.0;

                     float percentToMiddle = distanceToCenter / (ringWidth / 2.0);
                     gl_FragColor = vec4(ringColor * (1.0 - percentToMiddle), 1.0);
                  }
                  else
                     gl_FragColor = vec4(pipeColor, 1.0);
               }
               else
               {
                  if(positiveY)
                     gl_FragColor = vec4(pipeColor, 1.0);
                  else
                  {
                     float locationOfCenter = spaceBetweenRings + ringWidth / 2.0;
                     float distanceToCenter = locationOfCenter - moddedVal;
                     if(distanceToCenter < 0.0)
                        distanceToCenter *= -1.0;
                     
                     float percentToMiddle = distanceToCenter / (ringWidth/2.0);
                     gl_FragColor = vec4(ringColor*(1.0 - percentToMiddle), 1.0);
                  }
               }
            }
         </script>

         <script>
            // Add your own Javascript code/methods here.
            var scene;
            var camera;
            var sphere;
            var pipe;
            var deltaDelta;
            var deltaModifier = 1;
            var EdgeList;

            function mainFunction()
            {
               let renderer = new THREE.WebGLRenderer( { antialias: true } );
               renderer.setSize( window.innerWidth*.8, window.innerHeight*.8 );
               renderer.setPixelRatio( window.devicePixelRatio );
               renderer.setClearColor (0x0099FF, 1);
               document.body.appendChild( renderer.domElement );

               scene = new THREE.Scene();
               let aspect = window.innerWidth / window.innerHeight;
               camera = new THREE.PerspectiveCamera( 30, aspect, 1, 1000 );
               camera.position.z = 15;
               scene.add(camera);
               let cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
               
               let light = new THREE.AmbientLight( 0xFFFFFF );
               scene.add( light );
               
               //Handle Resize of window
               let resize = function () {
                  renderer.setSize(window.innerWidth*.8, window.innerHeight*.8);
                  camera.aspect = window.innerWidth / window.innerHeight;
                  camera.updateProjectionMatrix();
               };

               window.addEventListener("resize",resize, false);

               //render function
               delta = 0;
               deltaDelta = .01;
               let render = function () {
                  updateShaders();
                  requestAnimationFrame( render );
                  renderer.render( scene, camera );
               };
               example();
               render();
            }

            function getDynamicedgeShader(delta)
            {
               return new THREE.RawShaderMaterial({
                  vertexShader: document.getElementById('vertexShader').textContent,
                  fragmentShader: document.getElementById('edgeShader').textContent,
                  uniforms: 
                  {
                     ringWidth: {type: "float", value: 0.5},
                     ringColor: {type: "vec3", value: new THREE.Vector3(0/255, 202/225, 231/255)},
                     spaceBetweenRings: {type: "float", value: 0.5},
                     pipeColor: {type: "vec3", value: new THREE.Vector3(0, 0, 0)},
                     percentFilled: {type: "float", value: delta}
                  }
               }); 
            }

            function updateShaders()
            {
               //loop through all shaders we have
                  //each shader has a delta, and a delta delta
                  //the delta would be the current percent filled the shader is considered
                  //the delta delta would be the amount that shader is to change each function call.
                  //this number should be between 0.01 and 0.1. This represents the network flow in this edge
               //if this pipe has negative flow, pass in delta*-1
               var p = EdgeList.head;
               while(p != null)
               {
                  var thisPipeObject = p.value;
                  thisPipeObject.delta += thisPipeObject.deltaDelta;
                  if(thisPipeObject.delta > 1 || thisPipeObject.delta < -1)
                     thisPipeObject.delta = 0;
                  thisPipeObject.edge.material = getDynamicedgeShader(thisPipeObject.delta);

                  //Go to the next pipe
                  p = p.next;
               }
            }

            function addPipe(node1, node2, flow)
            {
               let deltaX = node1.position.x - node2.position.x;
               let deltaY = node1.position.y - node2.position.y;
               let deltaZ = node1.position.z - node2.position.z;

               let length = Math.sqrt(deltaX*deltaX + deltaY*deltaY + deltaZ*deltaZ);
               let pipeGeometry = new THREE.CylinderGeometry(0.5, 0.5, length);
               let  pipeMaterial = getDynamicedgeShader(0);
               pipe = new THREE.Mesh(pipeGeometry, pipeMaterial);

               pipe.position.set((node1.position.x + node2.position.x) / 2, (node1.position.y + node2.position.y) / 2, (node1.position.z + node2.position.z) / 2);
               pipe.lookAt(node1.position);
               pipe.rotateOnAxis(new THREE.Vector3(1, 0, 0), -Math.PI/2);
               scene.add(pipe);

               //This is the first edge
               if(EdgeList == null)
               {
                  EdgeList = new LinkedList({edge:pipe, delta:0, deltaDelta:0.01});
                  return pipe;
               }

               //Add this to the existing edge
               EdgeList.addToHead({edge:pipe, delta:0, deltaDelta: 0.01});
               return pipe;
            }

            function addNode(x, y, z)
            {
               let nodeGeometry = new THREE.SphereGeometry(2);
               let nodeMaterial = new THREE.MeshNormalMaterial();
               let node = new THREE.Mesh(nodeGeometry, nodeMaterial);


               node.position.set(x, y, z);

               scene.add(node);
               return node;
            }

            function example()
            {
               var n1 = addNode(0, 0, 0);
               var n2 = addNode(10, 10, -10);
               var pipe = addPipe(n1, n2, 0.01);
            }
         </script>
      </head>
      
      <body onload="mainFunction();">
      </body>
      
   </html>
