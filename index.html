   <!DOCTYPE html>
   <html>
      <head>
         <title>Main</title>
         <script  src="https://threejs.org/build/three.js"></script>
         <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
         <script  src="./LinkedList.js"></script>
         <script  src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
         <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
         <link rel="stylesheet" href="style.css">

         <script id="vertexShader" type="x-shader/x-vertex">
            precision highp float;

            attribute vec3 position;

            varying vec3 vPosition;

            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;

            void main()   {
               vPosition = position;

               gl_Position = projectionMatrix*modelViewMatrix*vec4(position, 1.0 );
            }
         </script>

         <script id="fragmentShader" type="x-shader/x-fragment">
            precision highp float;

            varying vec3 vPosition;
            varying vec3 vNormal;

            uniform float ringWidth;
            uniform vec3 ringColor;
            uniform float spaceBetweenRings;
            uniform vec3 pipeColor;
            uniform float percentFilled;

            void main()   {
               float newPosition = vPosition.y - (spaceBetweenRings + ringWidth)*percentFilled;
               float posY;
               bool positiveY;
               if(newPosition < 0.0)
               {
                  posY = newPosition * -1.0;
                  positiveY = false;
               }
               else
               {
                  posY = newPosition;
                  positiveY = true;
               }

               float moddedVal = mod(posY, ringWidth + spaceBetweenRings);
               if (moddedVal < ringWidth)
               {
                  if(positiveY)
                  {
                     float distanceToCenter = (ringWidth / 2.0) - moddedVal;
                     if(distanceToCenter < 0.0)
                        distanceToCenter *= -1.0;

                     float percentToMiddle = distanceToCenter / (ringWidth / 2.0);
                     gl_FragColor = vec4(ringColor * (1.0 - percentToMiddle), 1.0);
                  }
                  else
                     gl_FragColor = vec4(pipeColor, 1.0);
               }
               else
               {
                  if(positiveY)
                     gl_FragColor = vec4(pipeColor, 1.0);
                  else
                  {
                     float locationOfCenter = spaceBetweenRings + ringWidth / 2.0;
                     float distanceToCenter = locationOfCenter - moddedVal;
                     if(distanceToCenter < 0.0)
                        distanceToCenter *= -1.0;
                     
                     float percentToMiddle = distanceToCenter / (ringWidth/2.0);
                     gl_FragColor = vec4(ringColor*(1.0 - percentToMiddle), 1.0);
                  }
               }
            }
         </script>

         <script>
            var scene;
            var camera;
            var sphere;
            var pipe;
            var deltaDelta;
            var deltaModifier = 1;
            var EdgeList;

            var flowPath = [];

            var nodePos = [];
            nodePos.push({ x: 0, y: -15, z: 0});
            nodePos.push({ x: 0, y: 15, z: 0});
            nodePos.push({ x: 35, y: -15, z: 0});
            nodePos.push({ x: -37, y: 20, z: 0});
            nodePos.push({ x: 35, y: 15, z: 0});
            nodePos.push({ x: -37, y: -15, z: 0});

            function mainFunction()
            {  

               $('#generate').click(function(){
                  clearScene();
                  var start = document.getElementById("start").value;
                  var end = document.getElementById("end").value;
                  var tablesInput = getTable("input");
                  var maxFlow = fordFulkerson(tablesInput, start, end);
                  $('#alert').css("visibility", "visible");
                  $('#alert').empty();
                  $('#alert').append("Using Ford Fulkerson, the Max Flow from " + start + " to " + end + " is " + maxFlow);

                  // flowPath holds the edges and nodes which make up the max flow.
                  for(var i = 0; i < flowPath.length; i++){
                    console.log(flowPath[i]);
                  }

                  for(var i = 0; i < tablesInput.length; i++){
                     for(var j = 0; j < tablesInput[i].length; j++){
                        if(tablesInput[i][j] != ""){
                           var n1 = addNode(nodePos[i]['x'], nodePos[i]['y'], nodePos[i]['z']);
                           var n2 = addNode(nodePos[j]['x'], nodePos[j]['y'], nodePos[j]['z']);
                           var pipe = addPipe(n1, n2, tablesInput[i][j]*0.001);
                           render();
                        }
                     }
                  }
               })

               $('#clear').click(function(){
                  clearScene();
                  flowPath = [];
                  $('#alert').css("visibility", "hidden");
                  $('#alert').empty();
               })

               container = document.getElementById( 'canvas' );
               document.body.appendChild( container );

               let renderer = new THREE.WebGLRenderer( { antialias: true } );
               renderer.setSize( window.innerWidth*.6, window.innerHeight*.5 );
               renderer.setPixelRatio( window.devicePixelRatio );
               container.appendChild( renderer.domElement );
               
               scene = new THREE.Scene();
               let aspect = window.innerWidth / window.innerHeight;
               camera = new THREE.PerspectiveCamera( 30, aspect, 1, 1000 );
               camera.position.z = 80;
               camera.position.y = -20;
               scene.add(camera);
               let cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
               
               let light = new THREE.AmbientLight( 0xFFFFFF );
               scene.add( light );
               
               //Handle Resize of window
               let resize = function () {
                  renderer.setSize(window.innerWidth*.6, window.innerHeight*.5);
                  camera.aspect = window.innerWidth / window.innerHeight;
                  camera.updateProjectionMatrix();
               };

               window.addEventListener("resize",resize, false);

               //render function
               delta = 0;
               deltaDelta = .01;
               let render = function () {
                  updateShaders();
                  requestAnimationFrame( render );
                  renderer.render( scene, camera );
               };
            }

            function getDynamicEdgeShader(delta)
            {
               return new THREE.RawShaderMaterial({
                  vertexShader: document.getElementById('vertexShader').textContent,
                  fragmentShader: document.getElementById('fragmentShader').textContent,
                  uniforms: 
                  {
                     ringWidth: {type: "float", value: 0.5},
                     ringColor: {type: "vec3", value: new THREE.Vector3(0/255, 202/225, 231/255)},
                     spaceBetweenRings: {type: "float", value: 0.5},
                     pipeColor: {type: "vec3", value: new THREE.Vector3(0, 0, 0)},
                     percentFilled: {type: "float", value: delta}
                  }
               }); 
            }

            function updateShaders(delta)
            {
               //loop through all shaders we have
                  //each shader has a delta, and a delta delta
                  //the delta would be the current percent filled the shader is considered
                  //the delta delta would be the amount that shader is to change each function call.
                  //this number should be between 0.01 and 0.1. This represents the network flow in this edge
               //if this pipe has negative flow, pass in delta*-1
               var p = EdgeList.head;
               while(p != null)
               {
                  var thisPipeObject = p.value;
                  thisPipeObject.delta += thisPipeObject.deltaDelta;
                  if(thisPipeObject.delta > 1 || thisPipeObject.delta < -1)
                     thisPipeObject.delta = 0;
                  thisPipeObject.edge.material = getDynamicEdgeShader(thisPipeObject.delta);
                  //Go to the next pipe
                  p = p.next;
               }
            }

            function addPipe(node1, node2, delta)
            {
               let deltaX = node1.position.x - node2.position.x;
               let deltaY = node1.position.y - node2.position.y;
               let deltaZ = node1.position.z - node2.position.z;

               let length = Math.sqrt(deltaX*deltaX + deltaY*deltaY + deltaZ*deltaZ);
               let pipeGeometry = new THREE.CylinderGeometry(0.5, 0.5, length);
               let  pipeMaterial = getDynamicEdgeShader(0);
               pipe = new THREE.Mesh(pipeGeometry, pipeMaterial);

               pipe.position.set((node1.position.x + node2.position.x) / 2, (node1.position.y + node2.position.y) / 2, (node1.position.z + node2.position.z) / 2);
               pipe.lookAt(node1.position);
               pipe.rotateOnAxis(new THREE.Vector3(1, 0, 0), -Math.PI/2);
               scene.add(pipe);

               //This is the first edge
               if(EdgeList == null)
               {
                  EdgeList = new LinkedList({edge:pipe, delta:0, deltaDelta:delta});
                  return pipe;
               }
               //Add this to the existing edge
               EdgeList.addToHead({edge:pipe, delta:0, deltaDelta:delta});
               return pipe;
            }

            function addNode(x, y, z)
            {
               let nodeGeometry = new THREE.SphereGeometry(2);
               let nodeMaterial = new THREE.MeshNormalMaterial();
               let node = new THREE.Mesh(nodeGeometry, nodeMaterial);


               node.position.set(x, y, z);

               scene.add(node);
               return node;
            }

            function getTable(tableId) {
                var t = document.getElementById(tableId);
                var result = [];
                for(var j = 0; j < t.rows.length - 1; j++){
                  result[j] = [];
                  var r = t.rows[j+1];
                  var inputs = r.getElementsByTagName("input");
                  for (var i = 0; i < inputs.length; i++){
                    result[j][i] = inputs[i].value;
                  }
                }
                return result;
            }
            function clearScene() {
              for (let i = scene.children.length - 1; i >= 0; i--) {
                const object = scene.children[i];
                if (object.type === 'Mesh') {
                  object.geometry.dispose();
                  object.material.dispose();
                  scene.remove(object);
                }
              }
            }

            function bfs(rGraph, source, sink, parent)
            {
               var visited = [];
               var queue = [];
               //Number of Vertices
               var V=rGraph.length;
               
               for (var i = 0; i < V; i++) {
                    visited[i] = false;
                }

               queue.push(source);
               visited[source] = true;
               parent[source] = -1;

               while(queue.length != 0)
               {
                  var u = queue.shift();

                  for(var v=0; v<V; v++)
                  {
                     if(visited[v]==false && rGraph[u][v] > 0)
                     {
                        queue.push(v);
                        parent[v] = u;
                        visited[v] = true;
                     }
                  }
               }
               return (visited[sink] == true);
            }

            function fordFulkerson(graph, start, sink) {
               var rGraph = [];
               for(var u=0; u<graph.length; u++) {
                  var temp = [];
                  for(v=0; v<graph.length; v++){
                     temp.push(graph[u][v]);
                  }
                  rGraph.push(temp);
               }

               var parent = [];
               var maxFlow = 0;

               while(bfs(rGraph, start, sink, parent)) {
                  var pathFlow = Number.MAX_VALUE;
                  var x = -1;
                  var y = -1;
                  for (var v = sink; v != start; v = parent[v]) {
                     u = parent[v];
                     pathFlow = Math.min(pathFlow, rGraph[u][v]);
                     x = u;
                     y = v;
                  }
                  for(var v=sink; v!=start; v=parent[v])
                  {
                     u = parent[v];
                     rGraph[u][v] -= pathFlow;
                     rGraph[v][u] += pathFlow;
                  }
                  flowPath.push({x: parseInt(x), y: parseInt(y), flow: pathFlow});
                  maxFlow += pathFlow;
               }
               return maxFlow;
            }
         </script>
      </head>
      
      <body onload="mainFunction();">
         <div class="title" style="text-align: center"><h2>Ford Fulkerson Algorithm</h2></div>  
              <div class="col-sm-4">
                <div class="panel panel-default">
                  <div class="panel-heading" style="text-align: center; height: 60px;"><h4>Input Edge Weights</h4></div>
                  <div class="panel-body">

                    <table class="table table-bordered table-condensed" id="input">
                     <tbody>
                        <tr>
                           <th>Nodes</th>
                           <th>0</th>
                           <th>1</th>
                           <th>2</th>
                           <th>3</th>
                           <th>4</th>
                           <th>5</th>
                        </tr>
                       <tr>
                         <th>0</th>
                         <td><input type="text" class="form-control" disabled="disabled" /></td>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" /></td>
                       </tr>
                       <tr>
                         <th>1</th>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" disabled="disabled"/></td>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" /></td>
                       </tr>
                       <tr>
                         <th>2</th>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" disabled="disabled"/></td>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" /></td>
                       </tr>
                       <tr>
                         <th>3</th>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" disabled="disabled"/></td>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" /></td>
                       </tr>
                       <tr>
                         <th>4</th>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" disabled="disabled"/></td>
                         <td><input type="text" class="form-control" /></td>
                       </tr>
                       <tr>
                         <th>5</th>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" /></td>
                         <td><input type="text" class="form-control" disabled="disabled"/></td>
                       </tr>
                     </tbody>
                   </table>
                   <div class="col-sm-3">
                      <label>Start Node</label>
                      <input type="text" class="form-control" id="start"/>
                   </div>
                   <div class="col-sm-3">
                      <label>Target Node</label>
                      <input type="text" class="form-control" id="end"/>
                   </div>
                   <div class="col-sm-3">
                      <button type="button" id="clear" class="btn btn-warning" style="margin-top: 20px; width: 100px;">Clear</button>
                   </div>
                   <div class="col-sm-3">
                      <button type="button" id="generate" class="btn btn-primary" style="margin-top: 20px; width: 100px;">Generate</button>
                   </div>
                </div>
              </div>
             </div>
          <div class="col-sm-8">
            <div class="panel panel-default">
            <div class="panel-heading" style="text-align: center; height: 60px;"><h4>Visualization</h4></div>
               <div class="test" id="canvas"/>
            </div>
            </div>
            <div class="alert alert-success" id="alert" style="visibility: hidden; text-align: center"></div>
          </div>


      </body>
      
   </html>
